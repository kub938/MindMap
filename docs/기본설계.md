# 요구사항

1. 맨처음 페이지 들어오면 빈 root node만 생성
2. 커맨드  
   tab : 해당 노드의 자식 노드 생성
   ctrl(cmd) + enter : 해당 노드와 같은 레벨의 노드 생성(아래로)  
   enter : 해당 노드 텍스트 작성
3. 자체 파일 다운 가능
4. 로그인시 저장 가능
5. 임시 저장 기능 및 새로 고침해도 안날라가게
6. 사용자가 드래그앤 드롭으로 한개의 노드를 부모 노드 위에 1초 이상 올려놨을 때 해당 부모노드의 자식 노드로 변경

## 개발 순서

1. db 스키마 작성 후 api-types에 정의
2. api 개발
3. 프론트
4. 인프라 세팅

## 프로젝트 아키텍처

모노레포 방식 채택

### 이유

폴리레포 방식으로 관리 하는것도 고려해 봤지만 각각의 파트가 독립적이고 빌드 속도가 빠르다는 장점이 현재 프로젝트 사이즈와 혼자 개발한다는 점을 고려했을때 장점을 살릴 수 없음
독립적인것은 오히려 fe와 be 사이에 interface를 공유할 수 없기 때문에 런타임 에러와 작업 시간을 늘릴 수 있고 빌드 속도 또한 프로젝트 자체가 작기 때문에 오히려 각각의 레포를 빌드하는 시간이 더 오래 걸릴 수 있음
그렇기 때문에 코드 공유 및 일관성을 지키기 쉬운 모노레포 방식을 채택

### 설계

1. 폴더구조
   - root
     packages에 공통적으로 적용되는 모듈들을 담아 놓는다
     내부에는 config, shared가 있다
     shared에는 그외 프론트/백엔드에서 공통으로 사용하는 라이브러리를 넣는다

     packages
     |-- config
     |-- shared
     |-- ui

### build architecture

Workspaces : pnpm
build system : Turborepo

여기서 Turborepo 세팅의 핵심은 파이프 라인 개념 설계

- 어떤 작업(빌드, 테스트, 실행) 이 어떤 순서로, 무엇에 의존해서 실행되어야 하는지를 정의함
- 없다고 실행이 안되는건 아니지만 실행 과정을 관리해 주는 도구
- 없으면 의존성을 모두 파악하고 일일히 순서대로 폴더/파일 마다 다 빌드해 줘야함
- 패키지 매니저(pnpm)는 없으면 안돌아감
- workspaces의 역할은 여러 폴더를 하나로 묶어주고 packages/ui를 apps/web에서 쓸 수 있게 길을 연결해 줌

## Backend

### 프로토콜

REST API

### 프레임워크

NestJS

#### 사용이유

- 마인드맵 도메인은 노드 이동, 순서 재정렬, 순환 참조 검증 등 복잡한 비즈니스 로직이 핵심이었기 때문에,구조적 설계를 강제하는 NestJS가 Express보다 적합하다고 판단했습니다.
- Controller / Service / Module 단위의 책임 분리를 통해 트리 조작 로직을 서비스 계층에 명확히 위치시키고, 유지보수성과 확장성을 확보할 수 있습니다.
- DTO와 Validation Pipe를 활용해 API 입력을 타입 레벨과 런타임에서 동시에 검증하여, 클라이언트 상태 변화가 잦은 환경에서도 안정적인 API를 설계할 수 있습니다.
- Guard와 Interceptor를 활용한 인증·인가 처리로 노드 접근 권한 및 사용자 소유 맵 제어 로직을 선언적으로 관리할 수 있습니다.
- 모노레포 환경에서 공통 타입 및 도메인 로직을 공유하기 용이해, 프론트엔드와의 타입 정합성을 유지할 수 있습니다.

### DB

Postsql

### erd

![](https://velog.velcdn.com/images/kub938/post/9b39c256-6f7a-4143-84c7-f7894a5dfafa/image.png)

## 모노레포 구조 설계
