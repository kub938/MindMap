# 백엔드/프론트 설계

## 백엔드 Api 명세

https://tremendous-olivine-69e.notion.site/2fea869b9aa3806fa729ee08890aa6f2?v=2fea869b9aa381a889ad000ca1e02d6f&source=copy_link

1. 로그인 / 인증
   google auth, jwt token 사용
   - 이유
     자체적인 로그인 서비스보다 google auth를 사용한 로그인이 사용자 접근성 및 보안에 더 유리하다고 생각했습니다.
     또한 jwt token을 cookie로 받아 httpOnly 속성으로 XSS를 방어, sameSite 속성으로 CSRF를 방어 할 수 있다고 생각했습니다.

2. 마인드맵 생성 / 조회 / 삭제 / 수정
   기본 crud

3. Node 추가 / 삭제 / 이동
   Node에 대한 추가/삭제/이동/수정은 굉장히 많이 발생하기 때문에 프론트측에서 debounce를 통해 일정시간의 요청을 모아서 한번에 보낼 예정
   또한 백엔드는 요청 횟수를 줄이기 위해 api를 하나로 통합, 아래의 예리처럼 type을 받아 백엔드 내부에서 type에 따른 요청 처리
   request는 Operation[]이 들어올 것으로 예상
   또한 데이터에 before, after와 같이 이전 이후 정보를 줌으로써 이후 undo, redo와 같은 액션에 대한 확장성을 고려해 설계했습니다.

   ```javascript
       type Operation =
       {type: "ADD"; node: Node} |
       {type: "DELETE"; node: Node[]} |  //delete는 하위 트리까지 전송하기 때문에 Node[] 타입으로 받음
       {type: "MOVE"; nodeId: number; from: MoveInfo; to:MoveInfo} |
       {type: "UPDATE"; nodeId: number; before: Partial<Node>; after: Partial<Node>}
   ```

## 프론트 Mindmap 구성 로직

### Mindmap 구현

0. 기본적으로 Mindmap Tree는 인접리스트로 관리

   ```jsx
   //받은 노드 데이터 트리 변환
   //1️. parent_id 기준으로 그룹핑
   const childrenMap = useMemo(() => {
     const map = new Map<number | null, Node[]>();

     nodeList.forEach(node => {
       if (!map.has(node.parent_id)) {
         map.set(node.parent_id, []);
       }
       map.get(node.parent_id)!.push(node);
     });

     return map;
   }, [nodeList]);

   // 재귀 렌더
   function renderNode(node: Node) {
     const children = childrenMap.get(node.id) ?? [];

     return (
       <NodeView key={node.id} node={node}>
         {children.map(renderNode)}
       </NodeView>
     );
   }

   ```

1. Node 구성  
   `clientId` : 수정 / 삭제 로직중 프론트의 임의id 값이 백엔드 에서 지정한 id 값으로 변동됨으로써 발생하는 unmount를 방지하기 위해 삽입(아래 Node 위치 수정 로직 참고)  
   `parentId` : 인접 list 구성용  
   `order` : 같은 parentId일 경우 자식들의 순서를 정하기 위한 용도  
   `content` : node 내부 내용  
   `direction` : 루트노드 기준 왼쪽 오른쪽 확인 용도(이게 없으면 왼쪽 오른쪽 확인이 불가하고 홀/짝 같은 다른 로직으로 구현할 수 도 있지만 direction을 명시하는게 유지보수에 긍정적이라 판단)

   ```javascript
   interface Node{ //추후 확장성을 위해 Partial 설정
     id: number;
     mindmapId: number;
     clientId:number;
     parentId: number | null;
     order: number;
     content: string;
     direction: 'left' | 'right' | 'root';
     createdAt: string;
     updatedAt: string;
   }

   ```

2. content 수정
   한개의 node focus 후 enter시 콘텐츠 수정 가능
   내용 변경시 Operation 배열에 삽입

3. 노드 위치 수정
   1. Drag시 리렌더링 최적화를 위해 RAF 사용
   2. 다른 Node 위에 drop시  
      동작 : 해당 Node의 자식으로 이동  
      로직 : pickNode를 targetNode 위에(Bounding Box 안에) drop시 pickNode의 parentId를 target노드의 id로 변경, pickNode의 order 또한 해당 배열의 마지막 order + 1로변경
   3. 다른 Node의 위 or 아래 drop시
      동작 : drop 위치에 따라 같은 레벨의 해당 Node의 위 or 아래로 이동
      로직 : drop 위치와 근처 Node의 위치 계산 및 상하 판단 후 pickNode 의 parentId, order 변경

---

### 생각과정

1. 프론트에서 요청과 동시에 UI 부터 업데이트
2. response로 리스트 통째로 or 해당 노드만 받고 그걸로 업데이트
3. api를 일일이 보내지 말고 시간마다 update 시키는 로직으로 할까?

#### 선택(다 섞어버림)

1. 프론트에서 따로 업데이트할 목록 관리,
2. UI부터 업데이트 후 debounce를 이용해 일정 시간동안 수정 사항이 없으면 업데이트 하는 방식으로 진행
3. 요청 실패시 response로 toast 출력

그렇다면 request는 어떤식으로 모아야 할까

```jsx
interface MoveInfo = {
  parentId: number | null;
  order: number;
};

interface Node{ //추후 확장성을 위해 Partial 설정
	 id: number;
  mindmapId: number;
  parentId: number | null;
  order: number;
  content: string;
  direction: 'left' | 'right' | 'root';
  createdAt: string;
  updatedAt: string;
}

type Operation =
{type: "ADD"; node: Node} |
{type: "DELETE"; node: Node[]} |
{type: "MOVE"; nodeId: number; from: MoveInfo; to:MoveInfo} |
{type: "UPDATE"; nodeId: number; before: Partial<Node>; after: Partial<Node>}

```

음 그렇다면 ADD일때는 Node 전체를 보내서 그냥 그대로 Node 테이블에 삽입하면 되고

MOVE일 경우는 마우스 포인터에 따라 4가지로 나뉜다 상하좌우
인접한 노드의 상,하, 노드위 어디에 포인터가 있느냐에 따라서 놓는 위치가 달라진다

만약 위 아래일 경우 해당 레벨의 인접한 노드가 2개라면 각각의 합 / 2를 order에 집어넣어 사이에 들어가게 하고 노드가 1개라면 위치에 따라 order -1 또는 order +1을 해서 move 한다

이때 from에는 이동시킬 Node를 to에는 이동시킨 후 Node의 값을 삽입한다

//한 1초정도 위에 올려놓으면 어디로 이동하는지 스켈레톤도 보여주면 좋을 듯

DELETE의 경우
해당 노드의 children까지 모두 삭제하기 위해

Update의 경우

해당 노드

그리고 이것들을 UI로 처리하기 위하여

move(), delete(), update(), create() 함수를 만들어 처리한다

```javascript

const [mindmap, setMindmap] = useState<Node[]>([]);
const [selectedNodeId,setSelectNode] = useState:number(null);
let op:<Operation[]> = [] //이건 api 보낼용, api 보내고 나서 다시 비움
let undo<Operation[]> = [] //이건 api 보내고 나서도 남아있음 사용자의 ctrl+z, shift+ctrl+z에 반응하기 위해 만들어 놓음
let redo<Operation[]> = [] //undo에서 ctrl+z로 그냥 날려버리면 crtl+shift+z에 반응을 못하기 때문에 undo에서 pop한걸 다시 여기에 담아둠

//undo와 redo의 길이제한은 100개로 제한

useEffect(() => {
  //op 변경후 3초간 변경사항 없으면 api 호출
},[op])
function drawMindmap(){
	//마인드맵 ui 그리는 로직
}

function move(){
  //드래그앤 드롭시 실행
  //드롭할때 인근에 있는 노드의 위치에 따라 옮길 노드의 order값이 결정됨
  //이 위치값에 따른 Node 선택이 되는지 확인해봐야될듯? 어디서 된다고 보긴 했는데 확인필요
  //그리고 수정된 Node와 수정 전 Node를 op 배열에 넣고
  //ui업데이트
	setMindmap()
}

function delete(){
}

function update(){
}
function create(){
}

```

프론트 처리

1. 드래드앤 드롭 애니메이션
2. 노드 수정 로직
3. 명령 Operation 배열에 담기, 액션마다 담으면 됨
4. undo redo 로직  
   프론트에서 history로 담아두기 zustand 사용  
   stack 2개 써서 구현  
   localstorage에 담는건 용량 제한, 성능 저하 이슈로 배제
